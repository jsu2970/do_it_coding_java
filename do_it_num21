import java.util.Scanner;

class Merge {
    int count = 0;

    public void mergeSort(int arr[], int left, int right) {
        if (left >= right) {  //더 이상 쪼개지 못하는 경우 리턴 (0, 0) 등
            return;
        }

        // mid를 기준으로 두 부분으로 배열을 쪼갬
        int mid = (left + right) / 2;

        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);

        //병합 과정
        int temp[] = new int[right + 1];  // 스왑하고 보관할 임시 배열
        int index = left;  //임시 배열의 인덱스
        int start = left;  //왼쪽 배열의 시작 인덱스
        int end = mid + 1;  //오른쪽 배열의 시작 인덱스

        while(start <= mid && end <= right) {
            if (arr[start] > arr[end]) {  // 왼쪽에 있는 값이 오른쪽에 있는 값보다 큰 경우이므로 arr[end]가 왼쪽으로 이동하는 count를 세야 함
                count += end - index;  //이동할 거리
                temp[index++] = arr[end++];
            }
            else {
                temp[index++] = arr[start++];
            }
        }

        //왼쪽 배열의 값이 모두 temp값에 들어간 경우 남은 오른쪽 배열은 자기 위치 그대로 들어가므로 count변화 없음
        while(end <= right) {
            temp[index++] = arr[end++];
        }

        //오른쪽 배열의 값이 모두 temp값에 들어간 경우 남은 왼쪽 배열은 모두 오른쪽으로 이동하므로 count변화 없음
        while(start <= mid) {
            temp[index++] = arr[start++];
        }

        //배열 상태 변화를 원본 arr에 적용
        for (int i = left; i <= right; i++) {
            arr[i] = temp[i];
        }
    }
}

public class do_it_num21 {  //1517
    public static void main(String arg[]) {
        Scanner sc = new Scanner(System.in);

        System.out.print("데이터 개수: ");
        int length = sc.nextInt();

        System.out.println("배열 입력: ");
        int arr[] = new int[length];
        for (int i = 0; i < length; i++) {
            arr[i] = sc.nextInt();
        }

        long beforeTime = System.currentTimeMillis();  //시작 시간

        // 버블 정렬 대신 머지 소트를 이용해 이동 하기 전 원소의 위치가 이동 후 원래 위치보다 왼쪽에 갔을 때, 이동한 칸 개수를 세야 한다.
        // 버블 정렬은 오른쪽 -> 왼쪽으로 가는 스왑은 존재하지 않고, 작은 값이 오른쪽에 있는 경우 왼쪽으로 이동하기 때문에 왼쪽 -> 오른쪽으로만 이동한다.
        // 따라서 머지 소트 과정에서 왼쪽으로 이동한 칸 수를 세야 한다.

        Merge m = new Merge();
        m.mergeSort(arr, 0, length - 1);

        for(int i = 0; i < length; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println("\n" + m.count);

        //총 걸린 시간을 계산하는 과정
        long afterTime = System.currentTimeMillis();
        System.out.println("총 소요 시간: " + (afterTime - beforeTime) / 1000 + "초");
    }
}

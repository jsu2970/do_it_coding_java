import java.util.*;

public class do_it_num8 {
    public static void main(String arg[])
    {
        Scanner sc = new Scanner(System.in);

        System.out.print("수의 개수 입력: ");
        int num = sc.nextInt();

        System.out.println("배열 입력");
        int[] arr = new int[num];
        for (int i = 0; i < num; i++) {
            arr[i] = sc.nextInt();
        }

        long beforeTime = System.currentTimeMillis();  //시작 시간

        /* 주어진 n개의 숫자에서 다른 두 수의 합으로 표현되는 좋은 수 찾기 -> 투 포인터 사용
        정렬한 배열에서 자기 자신을 제외한 나머지 두 수를 더해서 자신을 만들 수 있는 두 수를 찾아야 함
        두 수의 합 > 좋은 수: end 인덱스를 감소시켜 값을 줄임
        두 수의 합 < 좋은 수: start 인덱스를 증가시켜 값을 늘림
        두 수의 합 = 좋은 수: count를 증가시키고 해당 좋은 수에 대한 탐색을 종료함
        start 인덱스가 end 인덱스보다 커진 경우에도 해당 좋은 수에 대한 탐색을 종료함
         */

        Arrays.sort(arr);  //퀵소트로 nlogn으로 정렬

        int count = 0;
        for (int i = 0; i < num; i++) {
            int start = 0, end = num - 1;

            if (arr[start] == arr[i]) {  //찾으려는 값은 더할 두 수에서 제외해야 함 -> start의 경우
                start++;
            }
            if (arr[end] == arr[i]) {  //end의 경우
                end--;
            }

            while (start < end) {
                int sum = arr[start] + arr[end];  //end 인덱스를 감소시켜 값을 줄임
                if (sum > arr[i]) {
                    end--;
                }
                else if (sum < arr[i]) {  //start 인덱스를 증가시켜 값을 늘림
                    start++;
                }
                else if (sum == arr[i]) {  //좋은 수를 찾으면 반복문 탈출
                    count++;
                    break;
                }
                else {
                    System.out.println("오류");
                }
            }
        }

        System.out.println("좋은 수 개수: " + count);

        //총 걸린 시간을 계산하는 과정
        long afterTime = System.currentTimeMillis();
        System.out.println("총 소요 시간: " + (afterTime - beforeTime) / 1000 + "초");
    }
}

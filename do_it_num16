import java.util.*;

//데이터의 위치를 기억할 별도의 클래스
class Data implements Comparable<Data>{
    int value;
    int index;

    Data (int value, int index) {
        this.value = value;
        this.index = index;
    }

    //value값을 기준으로 정렬할 수 있도록 기준을 제시함
    @Override
    public int compareTo(Data other) {
        return Integer.compare(this.value, other.value);
    }
}

public class do_it_num16 {  //1377
    public static void main(String arg[]) {
        Scanner sc = new Scanner(System.in);

        System.out.print("수의 개수: ");
        int length = sc.nextInt();

        System.out.println("차례대로 배열 입력: ");
        int arr[] = new int[length];
        for (int i = 0; i < length; i++) {
            arr[i] = sc.nextInt();
        }

        long beforeTime = System.currentTimeMillis();  //시작 시간

        /*
            버블 소트를 사용하면 O(n^2)이므로 qsort로 정렬한 뒤에 인덱스의 이동을 보고 버블소트가 시행 된 횟수를 추측하는 문제이다.
            (처음 인덱스 - 정렬 후 인덱스)값을 구하면 위치의 이동을 예측할 수 있다.
            +가 된 경우 처음 위치보다 왼쪽으로 이동한 값으로 작은 수인 것을 예측 할 수 있고, 작은 값이 오른쪽에서 한 칸씩 왼쪽으로 오므로
            인덱스 차이 값이 가장 높은 숫자가 가장 작은 숫자이다. 이 숫자는 마지막까지 이동하므로 이 숫자를 통해 총 루프 값을 예측 할 수 있다. -는 반대로 큰 수의 이동을 의미한다.
            따라서 총 루프 개수는 가장 작은 숫자가 이동한 +거리 만큼임을 알 수 있다.
            또한 버블 소트는 다 정렬이 되어도 마지막으로 정렬됐는지 한 번 검사해야 하므로 +1 만큼 루프가 추가된다.
         */

        Data remember[] = new Data[length];

        //처음 인덱스 위치 기억하기
        for (int i = 0; i < length; i++) {
            remember[i] = new Data(arr[i], i);
        }
        Arrays.sort(remember);  //value값을 기준으로 정렬

        Arrays.sort(arr);   //퀵소트 정렬
        
        //가장 큰 값 찾기
        int max = -500000;
        int loop;  //원래 인덱스 - 바뀐 인덱스
        for (int i = 0; i < length; i++) {
            loop = remember[i].index - i;
            if (loop > max) {
                max = loop;
            }
        }

        System.out.println(max + 1);  //한 번 더 검사한 루프 +1

        //총 걸린 시간을 계산하는 과정
        long afterTime = System.currentTimeMillis();
        System.out.println("총 소요 시간: " + (afterTime - beforeTime) / 1000 + "초");
    }
}

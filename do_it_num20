import java.util.Scanner;

class MergeSort {
    int temp[];

    MergeSort(int length) {
        temp = new int[length];
    }

    public void merge(int arr[], int left, int right) {
        if (left >= right) {  //두 부분으로 더 이상 쪼개지 못하는 경우 재귀 종료
            return;
        }

        int mid = (left + right) / 2;  //절반으로 쪼갬

        //두 부분으로 쪼갬
        merge(arr, left, mid);
        merge(arr, mid + 1, right);

        //병합 과정 -> mid까지가 왼쪽 배열, mid + 1부터 오른쪽 배열임
        int index = left;  //임시 배열에 사용할 포인터
        int start = left;  //왼쪽 배열의 시작 포인터
        int end = mid + 1;    //오른쪽 배열의 시작 포인터
        while (start <= mid && end <= right) {  //두 값을 비교하며 작은 값을 임시 배열에 저장함
            if (arr[start] < arr[end]) {  //왼쪽 배열의 값이 더 작은 경우
                temp[index++] = arr[start++];
            }
            else {
                temp[index++] = arr[end++];
            }
        }
        //왼쪽 부분이 남은 경우
        while (start <= mid) {
            temp[index++] = arr[start++];
        }
        //오른쪽 부분이 남은 경우
        while (end <= right) {
            temp[index++] = arr[end++];
        }

        //원본 배열에 temp배열의 내용을 복사
        for (int i = left; i <= right; i++) {
            arr[i] = temp[i];
        }
    }
}

public class do_it_num20 {  //2751
    public static void main(String arg[]) {
        Scanner sc = new Scanner(System.in);

        System.out.print("데이터 개수 입력: ");
        int length = sc.nextInt();

        System.out.println("배열 입력: ");
        int arr[] = new int[length];
        for (int i = 0; i < length; i++) {
            arr[i] = sc.nextInt();
        }

        long beforeTime = System.currentTimeMillis();  //시작 시간

        //merge sort로 문제 해결
        MergeSort merge = new MergeSort(length);
        merge.merge(arr, 0, length - 1);

        for (int i = 0; i < length; i++) {
            System.out.println(arr[i]);
        }

        //총 걸린 시간을 계산하는 과정
        long afterTime = System.currentTimeMillis();
        System.out.println("총 소요 시간: " + (afterTime - beforeTime) / 1000 + "초");
    }
}
